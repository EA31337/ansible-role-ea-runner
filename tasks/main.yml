---
- name: Check platform (non-Windows)
  when: ansible_os_family != "Windows"
  block:
    - name: Install winbind package
      ansible.builtin.apt:
        allow_unauthenticated: true
        install_recommends: "{{ 'yes' if wine_install_recommends else 'no' }}"
        name: '{{ item }}'
        state: present
        update_cache: true
      become: true
      with_items:
        - winbind
    - name: Query MT platform path
      changed_when: false
      ansible.builtin.find:
        paths: '{{ ansible_env.HOME }}/.wine'
        patterns: >-
          {{ mt_runner_mt_files[mt_runner_mt_version | int].terminal }}
        recurse: true
      register: mt_path_terminal
    - name: Set platform's directory path
      ansible.builtin.set_fact:
        mt_runner_mt_path: "{{ mt_path_terminal.files[0].path | dirname }}"
    - name: Set platform's terminal filepath
      ansible.builtin.set_fact:
        mt_runner_mt_terminal_path: "{{ mt_path_terminal.files[0].path }}"

- name: Convert paths (non-Windows)
  when: ansible_os_family != "Windows"
  block:
    - name: Converts platform's path to Unix
      changed_when: false
      # noqa command-instead-of-shell
      ansible.builtin.command: >-
        winepath {{ mt_runner_mt_path | quote }}
      environment:
        DISPLAY: "{{ xvfb_display }}"
      register: cmd_winepath_mt_path
    - name: Converts platform's terminal path to Unix
      changed_when: false
      # noqa command-instead-of-shell
      ansible.builtin.command: >-
        winepath {{ mt_runner_mt_terminal_path | quote }}
      environment:
        DISPLAY: "{{ xvfb_display }}"
      register: cmd_winepath_mt_terminal_path
    - name: Set MT platform path 1 for Unix
      ansible.builtin.set_fact:
        mt_runner_mt_path: "{{ cmd_winepath_mt_path.stdout }}"
    - name: Set MT platform path 2 for Unix
      ansible.builtin.set_fact:
        mt_runner_mt_terminal_path: "{{ cmd_winepath_mt_terminal_path.stdout }}"

- name: Creates tester.ini
  ansible.builtin.template:
    dest: '{{ mt_runner_mt_path }}/tester.ini'
    mode: "0644"
    src: '{{ mt_runner_mt_version }}/tester.ini.j2'

- name: Clean-up before the test (non-Windows)
  when: ansible_os_family != "Windows"
  block:
    - name: Kills any existing terminal processes
      ansible.builtin.command: pkill terminal
      changed_when: false
      failed_when: cmd_pkill_res.rc > 1
      register: cmd_pkill_res
    - name: Finds old logs
      changed_when: false
      ansible.builtin.find:
        paths: "{{ mt_runner_mt_path }}"
        patterns: "*.log"
        recurse: true
      register: mt_old_logs
    - name: Removes old log files
      ansible.builtin.file:
        path: "{{ item.path }}"
        state: absent
      loop: "{{ mt_old_logs.files }}"


- name: Runs terminal
  async: 600
  poll: 0
  changed_when: false
  ansible.builtin.command:
    argv:
      - "{{ mt_runner_cmd_prefix }}"
      - "{{ mt_runner_mt_terminal_path }}"
      - /config:tester.ini
  args:
    chdir: '{{ mt_runner_mt_path }}'
  environment:
    DISPLAY: "{{ xvfb_display }}"
  register: cmd_terminal_async

- name: Wait for the tester log file to be created
  ansible.builtin.wait_for:
    delay: 30
    path: |-
      {{ mt_runner_mt_path ~ '/logs/' ~ ('%Y%m%d' | strftime(ansible_date_time.epoch | int)) }}.log
    sleep: 10
    state: present
    timeout: 60
  register: task_wait_for_tester_logs

- name: Fetches tester log file
  ansible.builtin.slurp:
    src: "{{ task_wait_for_tester_logs.path }}"
  register: slurp_mt_tester_log_content

- name: Prints tester log file
  ansible.builtin.debug:
    msg: "{{ lookup('decode_utf16', slurp_mt_tester_log_content.content) }}"
  failed_when: |
    'tester not started' in debug_tester_log.msg
  register: debug_tester_log

- name: Wait until terminal exists
  ansible.builtin.async_status:
    jid: '{{ cmd_terminal_async.ansible_job_id }}'
  delay: 10
  register: cmd_terminal_async_status
  until: cmd_terminal_async_status is finished
  retries: 60

- name: Process logs
  block:
    - name: Finds all log files
      ansible.builtin.find:
        paths: "{{ mt_runner_mt_path }}"
        patterns: "*.log"
        recurse: true
      register: mt_log_files
    - name: Fetches log files
      ansible.builtin.slurp:
        src: "{{ item.path }}"
      loop: "{{ mt_log_files.files }}"
      register: mt_log_content
    - name: Prints log file
      ansible.builtin.debug:
        msg: "{{ lookup('decode_utf16', item.content) }}"
      loop: "{{ mt_log_content.results }}"

- name: Make sure all handlers run
  ansible.builtin.meta: flush_handlers
